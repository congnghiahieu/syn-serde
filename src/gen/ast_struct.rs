// This file is @generated by syn-serde-internal-codegen.
// It is not intended for manual editing.

use crate::*;
/// An adapter for [`struct@syn::Abi`].
#[derive(Serialize, Deserialize)]
pub struct Abi {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) name: Option<LitStr>,
}
/// An adapter for [`struct@syn::AngleBracketedGenericArguments`].
#[derive(Serialize, Deserialize)]
pub struct AngleBracketedGenericArguments {
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) colon2_token: bool,
    pub(crate) args: Punctuated<GenericArgument>,
}
/// An adapter for [`struct@syn::BareFnArg`].
#[derive(Serialize, Deserialize)]
pub struct BareFnArg {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) name: Option<Ident>,
    pub(crate) ty: Type,
}
/// An adapter for [`struct@syn::Binding`].
#[derive(Serialize, Deserialize)]
pub struct Binding {
    pub(crate) ident: Ident,
    pub(crate) ty: Type,
}
/// An adapter for [`struct@syn::Block`].
#[derive(Serialize, Deserialize)]
#[serde(transparent)]
pub struct Block {
    pub(crate) stmts: Vec<Stmt>,
}
/// An adapter for [`struct@syn::BoundLifetimes`].
#[derive(Serialize, Deserialize, Default)]
#[serde(transparent)]
pub struct BoundLifetimes {
    pub(crate) lifetimes: Punctuated<LifetimeDef>,
}
/// An adapter for [`struct@syn::ConstParam`].
#[derive(Serialize, Deserialize)]
pub struct ConstParam {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) ident: Ident,
    pub(crate) ty: Type,
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) eq_token: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) default: Option<Expr>,
}
/// An adapter for [`struct@syn::Constraint`].
#[derive(Serialize, Deserialize)]
pub struct Constraint {
    pub(crate) ident: Ident,
    pub(crate) bounds: Punctuated<TypeParamBound>,
}
/// An adapter for [`struct@syn::ExprArray`].
#[derive(Serialize, Deserialize)]
pub struct ExprArray {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) elems: Punctuated<Expr>,
}
/// An adapter for [`struct@syn::ExprAssign`].
#[derive(Serialize, Deserialize)]
pub struct ExprAssign {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) left: Box<Expr>,
    pub(crate) right: Box<Expr>,
}
/// An adapter for [`struct@syn::ExprAssignOp`].
#[derive(Serialize, Deserialize)]
pub struct ExprAssignOp {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) left: Box<Expr>,
    pub(crate) op: BinOp,
    pub(crate) right: Box<Expr>,
}
/// An adapter for [`struct@syn::ExprAsync`].
#[derive(Serialize, Deserialize)]
pub struct ExprAsync {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(rename = "move")]
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) capture: bool,
    #[serde(rename = "stmts")]
    pub(crate) block: Block,
}
/// An adapter for [`struct@syn::ExprAwait`].
#[derive(Serialize, Deserialize)]
pub struct ExprAwait {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) base: Box<Expr>,
}
/// An adapter for [`struct@syn::ExprBinary`].
#[derive(Serialize, Deserialize)]
pub struct ExprBinary {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) left: Box<Expr>,
    pub(crate) op: BinOp,
    pub(crate) right: Box<Expr>,
}
/// An adapter for [`struct@syn::ExprBlock`].
#[derive(Serialize, Deserialize)]
pub struct ExprBlock {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) label: Option<Label>,
    #[serde(rename = "stmts")]
    pub(crate) block: Block,
}
/// An adapter for [`struct@syn::ExprBox`].
#[derive(Serialize, Deserialize)]
pub struct ExprBox {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) expr: Box<Expr>,
}
/// An adapter for [`struct@syn::ExprBreak`].
#[derive(Serialize, Deserialize)]
pub struct ExprBreak {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) label: Option<Lifetime>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) expr: Option<Box<Expr>>,
}
/// An adapter for [`struct@syn::ExprCall`].
#[derive(Serialize, Deserialize)]
pub struct ExprCall {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) func: Box<Expr>,
    pub(crate) args: Punctuated<Expr>,
}
/// An adapter for [`struct@syn::ExprCast`].
#[derive(Serialize, Deserialize)]
pub struct ExprCast {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) expr: Box<Expr>,
    pub(crate) ty: Box<Type>,
}
/// An adapter for [`struct@syn::ExprClosure`].
#[derive(Serialize, Deserialize)]
pub struct ExprClosure {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(rename = "async")]
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) asyncness: bool,
    #[serde(rename = "static")]
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) movability: bool,
    #[serde(rename = "move")]
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) capture: bool,
    pub(crate) inputs: Punctuated<Pat>,
    #[serde(default)]
    pub(crate) output: ReturnType,
    pub(crate) body: Box<Expr>,
}
/// An adapter for [`struct@syn::ExprContinue`].
#[derive(Serialize, Deserialize)]
pub struct ExprContinue {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) label: Option<Lifetime>,
}
/// An adapter for [`struct@syn::ExprField`].
#[derive(Serialize, Deserialize)]
pub struct ExprField {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) base: Box<Expr>,
    #[serde(flatten)]
    pub(crate) member: Member,
}
/// An adapter for [`struct@syn::ExprForLoop`].
#[derive(Serialize, Deserialize)]
pub struct ExprForLoop {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) label: Option<Label>,
    pub(crate) pat: Pat,
    pub(crate) expr: Box<Expr>,
    pub(crate) body: Block,
}
/// An adapter for [`struct@syn::ExprGroup`].
#[derive(Serialize, Deserialize)]
pub struct ExprGroup {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) expr: Box<Expr>,
}
/// An adapter for [`struct@syn::ExprIf`].
#[derive(Serialize, Deserialize)]
pub struct ExprIf {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) cond: Box<Expr>,
    pub(crate) then_branch: Block,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) else_branch: Option<Box<Expr>>,
}
/// An adapter for [`struct@syn::ExprIndex`].
#[derive(Serialize, Deserialize)]
pub struct ExprIndex {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) expr: Box<Expr>,
    pub(crate) index: Box<Expr>,
}
/// An adapter for [`struct@syn::ExprLet`].
#[derive(Serialize, Deserialize)]
pub struct ExprLet {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) pat: Pat,
    pub(crate) expr: Box<Expr>,
}
/// An adapter for [`struct@syn::ExprLoop`].
#[derive(Serialize, Deserialize)]
pub struct ExprLoop {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) label: Option<Label>,
    pub(crate) body: Block,
}
/// An adapter for [`struct@syn::ExprMacro`].
#[derive(Serialize, Deserialize)]
pub struct ExprMacro {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(flatten)]
    pub(crate) mac: Macro,
}
/// An adapter for [`struct@syn::ExprMatch`].
#[derive(Serialize, Deserialize)]
pub struct ExprMatch {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) expr: Box<Expr>,
    pub(crate) arms: Vec<Arm>,
}
/// An adapter for [`struct@syn::ExprMethodCall`].
#[derive(Serialize, Deserialize)]
pub struct ExprMethodCall {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) receiver: Box<Expr>,
    pub(crate) method: Ident,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) turbofish: Option<MethodTurbofish>,
    pub(crate) args: Punctuated<Expr>,
}
/// An adapter for [`struct@syn::ExprParen`].
#[derive(Serialize, Deserialize)]
pub struct ExprParen {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) expr: Box<Expr>,
}
/// An adapter for [`struct@syn::ExprRange`].
#[derive(Serialize, Deserialize)]
pub struct ExprRange {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) from: Option<Box<Expr>>,
    pub(crate) limits: RangeLimits,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) to: Option<Box<Expr>>,
}
/// An adapter for [`struct@syn::ExprReference`].
#[derive(Serialize, Deserialize)]
pub struct ExprReference {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(rename = "mut")]
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) mutability: bool,
    pub(crate) expr: Box<Expr>,
}
/// An adapter for [`struct@syn::ExprRepeat`].
#[derive(Serialize, Deserialize)]
pub struct ExprRepeat {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) expr: Box<Expr>,
    pub(crate) len: Box<Expr>,
}
/// An adapter for [`struct@syn::ExprReturn`].
#[derive(Serialize, Deserialize)]
pub struct ExprReturn {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) expr: Option<Box<Expr>>,
}
/// An adapter for [`struct@syn::ExprStruct`].
#[derive(Serialize, Deserialize)]
pub struct ExprStruct {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) path: Path,
    pub(crate) fields: Punctuated<FieldValue>,
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) dot2_token: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) rest: Option<Box<Expr>>,
}
/// An adapter for [`struct@syn::ExprTry`].
#[derive(Serialize, Deserialize)]
pub struct ExprTry {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) expr: Box<Expr>,
}
/// An adapter for [`struct@syn::ExprTryBlock`].
#[derive(Serialize, Deserialize)]
pub struct ExprTryBlock {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(rename = "stmts")]
    pub(crate) block: Block,
}
/// An adapter for [`struct@syn::ExprTuple`].
#[derive(Serialize, Deserialize)]
pub struct ExprTuple {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) elems: Punctuated<Expr>,
}
/// An adapter for [`struct@syn::ExprType`].
#[derive(Serialize, Deserialize)]
pub struct ExprType {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) expr: Box<Expr>,
    pub(crate) ty: Box<Type>,
}
/// An adapter for [`struct@syn::ExprUnary`].
#[derive(Serialize, Deserialize)]
pub struct ExprUnary {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) op: UnOp,
    pub(crate) expr: Box<Expr>,
}
/// An adapter for [`struct@syn::ExprUnsafe`].
#[derive(Serialize, Deserialize)]
pub struct ExprUnsafe {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(rename = "stmts")]
    pub(crate) block: Block,
}
/// An adapter for [`struct@syn::ExprWhile`].
#[derive(Serialize, Deserialize)]
pub struct ExprWhile {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) label: Option<Label>,
    pub(crate) cond: Box<Expr>,
    pub(crate) body: Block,
}
/// An adapter for [`struct@syn::ExprYield`].
#[derive(Serialize, Deserialize)]
pub struct ExprYield {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) expr: Option<Box<Expr>>,
}
/// An adapter for [`struct@syn::FieldPat`].
#[derive(Serialize, Deserialize)]
pub struct FieldPat {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(flatten)]
    pub(crate) member: Member,
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) colon_token: bool,
    pub(crate) pat: Box<Pat>,
}
/// An adapter for [`struct@syn::FieldValue`].
#[derive(Serialize, Deserialize)]
pub struct FieldValue {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(flatten)]
    pub(crate) member: Member,
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) colon_token: bool,
    pub(crate) expr: Expr,
}
/// An adapter for [`struct@syn::FieldsNamed`].
#[derive(Serialize, Deserialize)]
#[serde(transparent)]
pub struct FieldsNamed {
    pub(crate) named: Punctuated<Field>,
}
/// An adapter for [`struct@syn::FieldsUnnamed`].
#[derive(Serialize, Deserialize)]
#[serde(transparent)]
pub struct FieldsUnnamed {
    pub(crate) unnamed: Punctuated<Field>,
}
/// An adapter for [`struct@syn::File`].
#[derive(Serialize, Deserialize)]
pub struct File {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) shebang: Option<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) items: Vec<Item>,
}
/// An adapter for [`struct@syn::ForeignItemFn`].
#[derive(Serialize, Deserialize)]
pub struct ForeignItemFn {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(default, skip_serializing_if = "Visibility::is_inherited")]
    pub(crate) vis: Visibility,
    #[serde(flatten)]
    pub(crate) sig: Signature,
}
/// An adapter for [`struct@syn::ForeignItemMacro`].
#[derive(Serialize, Deserialize)]
pub struct ForeignItemMacro {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(flatten)]
    pub(crate) mac: Macro,
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) semi_token: bool,
}
/// An adapter for [`struct@syn::ForeignItemStatic`].
#[derive(Serialize, Deserialize)]
pub struct ForeignItemStatic {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(default, skip_serializing_if = "Visibility::is_inherited")]
    pub(crate) vis: Visibility,
    #[serde(rename = "mut")]
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) mutability: bool,
    pub(crate) ident: Ident,
    pub(crate) ty: Box<Type>,
}
/// An adapter for [`struct@syn::ForeignItemType`].
#[derive(Serialize, Deserialize)]
pub struct ForeignItemType {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(default, skip_serializing_if = "Visibility::is_inherited")]
    pub(crate) vis: Visibility,
    pub(crate) ident: Ident,
}
/// An adapter for [`struct@syn::ImplItemConst`].
#[derive(Serialize, Deserialize)]
pub struct ImplItemConst {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(default, skip_serializing_if = "Visibility::is_inherited")]
    pub(crate) vis: Visibility,
    #[serde(rename = "default")]
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) defaultness: bool,
    pub(crate) ident: Ident,
    pub(crate) ty: Type,
    pub(crate) expr: Expr,
}
/// An adapter for [`struct@syn::ImplItemMacro`].
#[derive(Serialize, Deserialize)]
pub struct ImplItemMacro {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(flatten)]
    pub(crate) mac: Macro,
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) semi_token: bool,
}
/// An adapter for [`struct@syn::ImplItemMethod`].
#[derive(Serialize, Deserialize)]
pub struct ImplItemMethod {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(default, skip_serializing_if = "Visibility::is_inherited")]
    pub(crate) vis: Visibility,
    #[serde(rename = "default")]
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) defaultness: bool,
    #[serde(flatten)]
    pub(crate) sig: Signature,
    #[serde(rename = "stmts")]
    pub(crate) block: Block,
}
/// An adapter for [`struct@syn::ImplItemType`].
#[derive(Serialize, Deserialize)]
pub struct ImplItemType {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(default, skip_serializing_if = "Visibility::is_inherited")]
    pub(crate) vis: Visibility,
    #[serde(rename = "default")]
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) defaultness: bool,
    pub(crate) ident: Ident,
    #[serde(default, skip_serializing_if = "Generics::is_none")]
    pub(crate) generics: Generics,
    pub(crate) ty: Type,
}
/// An adapter for [`struct@syn::Index`].
#[derive(Serialize, Deserialize)]
#[serde(transparent)]
pub struct Index {
    pub(crate) index: u32,
}
/// An adapter for [`struct@syn::ItemConst`].
#[derive(Serialize, Deserialize)]
pub struct ItemConst {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(default, skip_serializing_if = "Visibility::is_inherited")]
    pub(crate) vis: Visibility,
    pub(crate) ident: Ident,
    pub(crate) ty: Box<Type>,
    pub(crate) expr: Box<Expr>,
}
/// An adapter for [`struct@syn::ItemEnum`].
#[derive(Serialize, Deserialize)]
pub struct ItemEnum {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(default, skip_serializing_if = "Visibility::is_inherited")]
    pub(crate) vis: Visibility,
    pub(crate) ident: Ident,
    #[serde(default, skip_serializing_if = "Generics::is_none")]
    pub(crate) generics: Generics,
    pub(crate) variants: Punctuated<Variant>,
}
/// An adapter for [`struct@syn::ItemExternCrate`].
#[derive(Serialize, Deserialize)]
pub struct ItemExternCrate {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(default, skip_serializing_if = "Visibility::is_inherited")]
    pub(crate) vis: Visibility,
    pub(crate) ident: Ident,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) rename: Option<Ident>,
}
/// An adapter for [`struct@syn::ItemFn`].
#[derive(Serialize, Deserialize)]
pub struct ItemFn {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(default, skip_serializing_if = "Visibility::is_inherited")]
    pub(crate) vis: Visibility,
    #[serde(flatten)]
    pub(crate) sig: Signature,
    #[serde(rename = "stmts")]
    pub(crate) block: Box<Block>,
}
/// An adapter for [`struct@syn::ItemForeignMod`].
#[derive(Serialize, Deserialize)]
pub struct ItemForeignMod {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) abi: Abi,
    pub(crate) items: Vec<ForeignItem>,
}
/// An adapter for [`struct@syn::ItemMacro`].
#[derive(Serialize, Deserialize)]
pub struct ItemMacro {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) ident: Option<Ident>,
    #[serde(flatten)]
    pub(crate) mac: Macro,
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) semi_token: bool,
}
/// An adapter for [`struct@syn::ItemMacro2`].
#[derive(Serialize, Deserialize)]
pub struct ItemMacro2 {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(default, skip_serializing_if = "Visibility::is_inherited")]
    pub(crate) vis: Visibility,
    pub(crate) ident: Ident,
    pub(crate) rules: TokenStream,
}
/// An adapter for [`struct@syn::ItemStatic`].
#[derive(Serialize, Deserialize)]
pub struct ItemStatic {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(default, skip_serializing_if = "Visibility::is_inherited")]
    pub(crate) vis: Visibility,
    #[serde(rename = "mut")]
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) mutability: bool,
    pub(crate) ident: Ident,
    pub(crate) ty: Box<Type>,
    pub(crate) expr: Box<Expr>,
}
/// An adapter for [`struct@syn::ItemTraitAlias`].
#[derive(Serialize, Deserialize)]
pub struct ItemTraitAlias {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(default, skip_serializing_if = "Visibility::is_inherited")]
    pub(crate) vis: Visibility,
    pub(crate) ident: Ident,
    #[serde(default, skip_serializing_if = "Generics::is_none")]
    pub(crate) generics: Generics,
    pub(crate) bounds: Punctuated<TypeParamBound>,
}
/// An adapter for [`struct@syn::ItemType`].
#[derive(Serialize, Deserialize)]
pub struct ItemType {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(default, skip_serializing_if = "Visibility::is_inherited")]
    pub(crate) vis: Visibility,
    pub(crate) ident: Ident,
    #[serde(default, skip_serializing_if = "Generics::is_none")]
    pub(crate) generics: Generics,
    pub(crate) ty: Box<Type>,
}
/// An adapter for [`struct@syn::ItemUnion`].
#[derive(Serialize, Deserialize)]
pub struct ItemUnion {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(default, skip_serializing_if = "Visibility::is_inherited")]
    pub(crate) vis: Visibility,
    pub(crate) ident: Ident,
    #[serde(default, skip_serializing_if = "Generics::is_none")]
    pub(crate) generics: Generics,
    pub(crate) fields: FieldsNamed,
}
/// An adapter for [`struct@syn::ItemUse`].
#[derive(Serialize, Deserialize)]
pub struct ItemUse {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(default, skip_serializing_if = "Visibility::is_inherited")]
    pub(crate) vis: Visibility,
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) leading_colon: bool,
    pub(crate) tree: UseTree,
}
/// An adapter for [`struct@syn::Label`].
#[derive(Serialize, Deserialize)]
#[serde(transparent)]
pub struct Label {
    pub(crate) name: Lifetime,
}
/// An adapter for [`struct@syn::Lifetime`].
#[derive(Serialize, Deserialize, Clone)]
#[serde(transparent)]
pub struct Lifetime {
    pub(crate) ident: Ident,
}
/// An adapter for [`struct@syn::Local`].
#[derive(Serialize, Deserialize)]
pub struct Local {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) pat: Pat,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) init: Option<Box<Expr>>,
}
/// An adapter for [`struct@syn::Macro`].
#[derive(Serialize, Deserialize)]
pub struct Macro {
    pub(crate) path: Path,
    pub(crate) delimiter: MacroDelimiter,
    pub(crate) tokens: TokenStream,
}
/// An adapter for [`struct@syn::MetaList`].
#[derive(Serialize, Deserialize)]
pub struct MetaList {
    pub(crate) path: Path,
    pub(crate) nested: Punctuated<NestedMeta>,
}
/// An adapter for [`struct@syn::MetaNameValue`].
#[derive(Serialize, Deserialize)]
pub struct MetaNameValue {
    pub(crate) path: Path,
    pub(crate) lit: Lit,
}
/// An adapter for [`struct@syn::MethodTurbofish`].
#[derive(Serialize, Deserialize)]
pub struct MethodTurbofish {
    pub(crate) args: Punctuated<GenericMethodArgument>,
}
/// An adapter for [`struct@syn::ParenthesizedGenericArguments`].
#[derive(Serialize, Deserialize)]
pub struct ParenthesizedGenericArguments {
    pub(crate) inputs: Punctuated<Type>,
    #[serde(default)]
    pub(crate) output: ReturnType,
}
/// An adapter for [`struct@syn::PatBox`].
#[derive(Serialize, Deserialize)]
pub struct PatBox {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) pat: Box<Pat>,
}
/// An adapter for [`struct@syn::PatIdent`].
#[derive(Serialize, Deserialize)]
pub struct PatIdent {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(rename = "ref")]
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) by_ref: bool,
    #[serde(rename = "mut")]
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) mutability: bool,
    pub(crate) ident: Ident,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) subpat: Option<Box<Pat>>,
}
/// An adapter for [`struct@syn::PatLit`].
#[derive(Serialize, Deserialize)]
pub struct PatLit {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) expr: Box<Expr>,
}
/// An adapter for [`struct@syn::PatMacro`].
#[derive(Serialize, Deserialize)]
pub struct PatMacro {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(flatten)]
    pub(crate) mac: Macro,
}
/// An adapter for [`struct@syn::PatRange`].
#[derive(Serialize, Deserialize)]
pub struct PatRange {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) lo: Box<Expr>,
    pub(crate) limits: RangeLimits,
    pub(crate) hi: Box<Expr>,
}
/// An adapter for [`struct@syn::PatReference`].
#[derive(Serialize, Deserialize)]
pub struct PatReference {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(rename = "mut")]
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) mutability: bool,
    pub(crate) pat: Box<Pat>,
}
/// An adapter for [`struct@syn::PatRest`].
#[derive(Serialize, Deserialize)]
pub struct PatRest {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
}
/// An adapter for [`struct@syn::PatSlice`].
#[derive(Serialize, Deserialize)]
pub struct PatSlice {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) elems: Punctuated<Pat>,
}
/// An adapter for [`struct@syn::PatStruct`].
#[derive(Serialize, Deserialize)]
pub struct PatStruct {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) path: Path,
    pub(crate) fields: Punctuated<FieldPat>,
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) dot2_token: bool,
}
/// An adapter for [`struct@syn::PatTuple`].
#[derive(Serialize, Deserialize)]
pub struct PatTuple {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) elems: Punctuated<Pat>,
}
/// An adapter for [`struct@syn::PatTupleStruct`].
#[derive(Serialize, Deserialize)]
pub struct PatTupleStruct {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) path: Path,
    pub(crate) pat: PatTuple,
}
/// An adapter for [`struct@syn::PatType`].
#[derive(Serialize, Deserialize)]
pub struct PatType {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) pat: Box<Pat>,
    pub(crate) ty: Box<Type>,
}
/// An adapter for [`struct@syn::PatWild`].
#[derive(Serialize, Deserialize)]
pub struct PatWild {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
}
/// An adapter for [`struct@syn::Path`].
#[derive(Serialize, Deserialize)]
pub struct Path {
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) leading_colon: bool,
    pub(crate) segments: Punctuated<PathSegment>,
}
/// An adapter for [`struct@syn::PathSegment`].
#[derive(Serialize, Deserialize)]
pub struct PathSegment {
    pub(crate) ident: Ident,
    #[serde(default, skip_serializing_if = "PathArguments::is_none")]
    pub(crate) arguments: PathArguments,
}
/// An adapter for [`struct@syn::PredicateEq`].
#[derive(Serialize, Deserialize)]
pub struct PredicateEq {
    pub(crate) lhs_ty: Type,
    pub(crate) rhs_ty: Type,
}
/// An adapter for [`struct@syn::PredicateLifetime`].
#[derive(Serialize, Deserialize)]
pub struct PredicateLifetime {
    pub(crate) lifetime: Lifetime,
    pub(crate) bounds: Punctuated<Lifetime>,
}
/// An adapter for [`struct@syn::QSelf`].
#[derive(Serialize, Deserialize)]
pub struct QSelf {
    pub(crate) ty: Box<Type>,
    pub(crate) position: usize,
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) as_token: bool,
}
/// An adapter for [`struct@syn::Signature`].
#[derive(Serialize, Deserialize)]
pub struct Signature {
    #[serde(rename = "const")]
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) constness: bool,
    #[serde(rename = "async")]
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) asyncness: bool,
    #[serde(rename = "unsafe")]
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) unsafety: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) abi: Option<Abi>,
    pub(crate) ident: Ident,
    #[serde(default, skip_serializing_if = "Generics::is_none")]
    pub(crate) generics: Generics,
    pub(crate) inputs: Punctuated<FnArg>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) variadic: Option<Variadic>,
    #[serde(default)]
    pub(crate) output: ReturnType,
}
/// An adapter for [`struct@syn::TraitBound`].
#[derive(Serialize, Deserialize)]
pub struct TraitBound {
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) paren_token: bool,
    #[serde(default, skip_serializing_if = "TraitBoundModifier::is_none")]
    pub(crate) modifier: TraitBoundModifier,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) lifetimes: Option<BoundLifetimes>,
    pub(crate) path: Path,
}
/// An adapter for [`struct@syn::TraitItemConst`].
#[derive(Serialize, Deserialize)]
pub struct TraitItemConst {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) ident: Ident,
    pub(crate) ty: Type,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) default: Option<Expr>,
}
/// An adapter for [`struct@syn::TraitItemMacro`].
#[derive(Serialize, Deserialize)]
pub struct TraitItemMacro {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    #[serde(flatten)]
    pub(crate) mac: Macro,
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) semi_token: bool,
}
/// An adapter for [`struct@syn::TypeArray`].
#[derive(Serialize, Deserialize)]
pub struct TypeArray {
    pub(crate) elem: Box<Type>,
    pub(crate) len: Expr,
}
/// An adapter for [`struct@syn::TypeBareFn`].
#[derive(Serialize, Deserialize)]
pub struct TypeBareFn {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) lifetimes: Option<BoundLifetimes>,
    #[serde(rename = "unsafe")]
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) unsafety: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) abi: Option<Abi>,
    pub(crate) inputs: Punctuated<BareFnArg>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) variadic: Option<Variadic>,
    #[serde(default)]
    pub(crate) output: ReturnType,
}
/// An adapter for [`struct@syn::TypeGroup`].
#[derive(Serialize, Deserialize)]
pub struct TypeGroup {
    pub(crate) elem: Box<Type>,
}
/// An adapter for [`struct@syn::TypeImplTrait`].
#[derive(Serialize, Deserialize)]
pub struct TypeImplTrait {
    pub(crate) bounds: Punctuated<TypeParamBound>,
}
/// An adapter for [`struct@syn::TypeMacro`].
#[derive(Serialize, Deserialize)]
pub struct TypeMacro {
    #[serde(flatten)]
    pub(crate) mac: Macro,
}
/// An adapter for [`struct@syn::TypeParen`].
#[derive(Serialize, Deserialize)]
pub struct TypeParen {
    pub(crate) elem: Box<Type>,
}
/// An adapter for [`struct@syn::TypePtr`].
#[derive(Serialize, Deserialize)]
pub struct TypePtr {
    #[serde(rename = "const")]
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) const_token: bool,
    #[serde(rename = "mut")]
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) mutability: bool,
    pub(crate) elem: Box<Type>,
}
/// An adapter for [`struct@syn::TypeReference`].
#[derive(Serialize, Deserialize)]
pub struct TypeReference {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) lifetime: Option<Lifetime>,
    #[serde(rename = "mut")]
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) mutability: bool,
    pub(crate) elem: Box<Type>,
}
/// An adapter for [`struct@syn::TypeSlice`].
#[derive(Serialize, Deserialize)]
pub struct TypeSlice {
    pub(crate) elem: Box<Type>,
}
/// An adapter for [`struct@syn::TypeTraitObject`].
#[derive(Serialize, Deserialize)]
pub struct TypeTraitObject {
    #[serde(rename = "dyn")]
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) dyn_token: bool,
    pub(crate) bounds: Punctuated<TypeParamBound>,
}
/// An adapter for [`struct@syn::TypeTuple`].
#[derive(Serialize, Deserialize)]
pub struct TypeTuple {
    pub(crate) elems: Punctuated<Type>,
}
/// An adapter for [`struct@syn::UseGroup`].
#[derive(Serialize, Deserialize)]
#[serde(transparent)]
pub struct UseGroup {
    pub(crate) items: Punctuated<UseTree>,
}
/// An adapter for [`struct@syn::UseName`].
#[derive(Serialize, Deserialize)]
#[serde(transparent)]
pub struct UseName {
    pub(crate) ident: Ident,
}
/// An adapter for [`struct@syn::UsePath`].
#[derive(Serialize, Deserialize)]
pub struct UsePath {
    pub(crate) ident: Ident,
    pub(crate) tree: Box<UseTree>,
}
/// An adapter for [`struct@syn::UseRename`].
#[derive(Serialize, Deserialize)]
pub struct UseRename {
    pub(crate) ident: Ident,
    pub(crate) rename: Ident,
}
/// An adapter for [`struct@syn::Variadic`].
#[derive(Serialize, Deserialize)]
pub struct Variadic {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
}
/// An adapter for [`struct@syn::Variant`].
#[derive(Serialize, Deserialize)]
pub struct Variant {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub(crate) attrs: Vec<Attribute>,
    pub(crate) ident: Ident,
    pub(crate) fields: Fields,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) discriminant: Option<Expr>,
}
/// An adapter for [`struct@syn::VisRestricted`].
#[derive(Serialize, Deserialize)]
pub struct VisRestricted {
    #[serde(default, skip_serializing_if = "not")]
    pub(crate) in_token: bool,
    pub(crate) path: Box<Path>,
}
/// An adapter for [`struct@syn::WhereClause`].
#[derive(Serialize, Deserialize)]
#[serde(transparent)]
pub struct WhereClause {
    pub(crate) predicates: Punctuated<WherePredicate>,
}
