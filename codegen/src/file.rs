use crate::Result;
use proc_macro2::TokenStream;
use std::fmt;
use std::fs;
use std::io::Write;
use std::path::Path;

pub(crate) fn write<P: AsRef<Path>>(path: P, content: TokenStream) -> Result<()> {
    let mut formatted = Vec::new();
    writeln!(
        formatted,
        "// This file is @generated by syn-serde-internal-codegen.\n\
         // It is not intended for manual editing.\n"
    )?;

    let mut config = rustfmt::Config::default();
    config.set().emit_mode(rustfmt::EmitMode::Stdout);
    config.set().verbose(rustfmt::Verbosity::Quiet);
    config.set().format_macro_matchers(true);
    config.set().normalize_doc_attributes(true);

    let mut session = rustfmt::Session::new(config, Some(&mut formatted));
    session
        .format(rustfmt::Input::Text(content.to_string()))
        .map_err(RustfmtError)?;
    drop(session);

    if path.as_ref().is_file() && fs::read(&path)? == formatted {
        return Ok(());
    }

    fs::write(path, formatted)?;
    Ok(())
}

#[derive(Debug)]
struct RustfmtError(rustfmt::ErrorKind);

impl fmt::Display for RustfmtError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

impl std::error::Error for RustfmtError {}
