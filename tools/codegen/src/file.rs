use std::{
    path::{Path, PathBuf},
    process::Command,
};

use anyhow::{bail, Result};
use fs_err as fs;
use proc_macro2::TokenStream;

pub(crate) fn workspace_root() -> PathBuf {
    let mut dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    dir.pop(); // codegen
    dir.pop(); // tools
    dir
}

fn header() -> String {
    concat!(
        "// This file is @generated by ",
        env!("CARGO_BIN_NAME"),
        ".\n",
        "// It is not intended for manual editing.\n",
        "\n",
    )
    .into()
}

pub(crate) fn write(path: &Path, contents: &TokenStream) -> Result<()> {
    let contents = &contents.to_string();

    let tmpdir = tempfile::tempdir()?;
    let tmpfile = &tmpdir.path().join("generated");
    fs::write(tmpfile, &contents)?;
    fs::copy(workspace_root().join(".rustfmt.toml"), tmpdir.path().join(".rustfmt.toml"))?;

    let status = Command::new("rustfmt")
        .arg(tmpfile)
        .args(&["--config", "normalize_doc_attributes=true,format_macro_matchers=true"])
        .status()?;
    if !status.success() {
        bail!("rustfmt didn't exit successfully");
    }

    let mut out = header().into_bytes();
    out.append(&mut fs::read(tmpfile)?);
    if path.is_file() && fs::read(&path)? == out {
        return Ok(());
    }
    fs::write(path, out)?;
    Ok(())
}
